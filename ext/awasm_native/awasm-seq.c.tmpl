#include <assert.h>
#include <errno.h>

#include "$-s.h"
#include "awasm-alloc.h"

$includes

void
$s_clear($s *seq, uint$w_t start, uint$w_t end) {
  for(uint$w_t i = start; i < end - 1; i++) {
    $S_DATA(seq)[i].free = true;
    $S_DATA(seq)[i].next_free = i + 1;
  }
  $S_DATA(seq)[end - 1].next_free = $S_NULL_IDX;
  $S_DATA(seq)[end - 1].free = true;

  seq->last_free = end - 1;
}


$e *
$s_data($s *seq) {
 return $S_DATA(seq);
}

awasm_success
$s_init($s *seq, uint$w_t capa) {

#if $embed > 0
  seq->data = NULL;
  seq->capa = AWASM_SEQ_EMBED_N;
#else
  size_t size = sizeof($e) * capa;
  seq->data = awasm_malloc(size);
  if(seq->data == NULL) {
    awasm_set_error(AWASM_ERROR_TYPE_MEMORY, AWASM_ERROR_CODE_NONE,
        NULL, "Allocationg buffer of size %zu failed: %s", size, strerror(errno));
    return false;
  }
  seq->capa = capa;
#endif

  seq->first_free = 0;
  seq->len = 0;

  $s_clear(seq, 0, seq->capa);
  return true;
}

awasm_success
_$s_grow($s *seq) {
  uint$w_t new_capa = seq->capa + seq->capa / 2;

#if $embed > 0
  if(seq->data == NULL) {
    seq->data = malloc(sizeof($e) * new_capa);
    memcpy(seq->data, seq->_data, sizeof($e) * seq->capa);
    goto update;
  }
#endif

  {
    size_t size = sizeof($e) * new_capa;
    $e *new_data = awasm_realloc(seq->data, size);

    if(AWASM_UNLIKELY(new_data == NULL)) {
      awasm_set_error(AWASM_ERROR_TYPE_MEMORY, AWASM_ERROR_CODE_NONE,
          NULL, "Reallocationg buffer of size %zu failed: %s", size, strerror(errno));
      return false;
    }
  }
update:
  seq->first_free = seq->capa;
  $s_clear(seq, seq->capa, new_capa);
  seq->capa = new_capa;
  return true;
}

$e *
$s_delete($s *seq, $e *e) {
  uint$w_t idx = $s_index(seq, e);

  e->next_free = seq->first_free;
  e->free = true;

  // only free slot
  if(seq->last_free == $S_NULL_IDX) {
    seq->last_free = idx;
  }

  seq->first_free = idx;
  seq->len--;
  return e;
}

bool
$s_eql($s *a, $s *b) {
  $eql
}

bool
$s_find($s *seq, $e *value, uint$w_t *index) {

  if(seq->len == 0) return false;

  for(uint$w_t i = 0; i < seq->capa; i++) {
    if(!$S_DATA(seq)[i].free) {
      if($s_cmp(value, &$S_DATA(seq)[i])) {
        if(index != NULL) *index = i;
        return true;
      }
    }
  }
  return false;
}

void
$s_destroy($s *seq) {
  awasm_free(seq->data);
}
