#pragma once

#include <stdint.h>
#include "awasm-error.h"

$includes

#if $embed > 0
#  define $S_DATA(seq) (seq->data != NULL ? seq->data : seq->_data)
#else
#  define $S_DATA(seq) (seq->data)
#endif

#define $S_NULL_IDX ((uint$w_t)-1)

typedef struct $s {
  uint$w_t capa;
  uint$w_t len;
  uint$w_t first_free;
  uint$w_t last_free;
  $e *data;

#if $embed > 0
  $e _data[$embed];
#endif
} $s;

static inline uint32_t
$s_index($s *seq, $e *e) {
  return (uint32_t)(e - $S_DATA(seq));
}

static inline $e *
$s_get($s *seq, uint$w_t index) {
#if 0
  if(index >= seq->capa) {
    return NULL;
  }
  return $S_DATA(seq)[index].free ? NULL : &$S_DATA(seq)[index];
#endif
  return &$S_DATA(seq)[index];
}

awasm_success _$s_grow($s *seq);

static inline awasm_success
$s_push($s *seq, $e **ee, uint$w_t *ridx) {
  if(seq->first_free == $S_NULL_IDX) {
    if(!_$s_grow(seq)) {
      return false;
    }
  }

  {
    $e *entry = &$S_DATA(seq)[seq->first_free];

    uint$w_t idx = seq->first_free;

    // used up last free slot
    if(entry->next_free == $S_NULL_IDX){
      assert(idx == seq->last_free);
      seq->last_free = $S_NULL_IDX;
    }

    seq->first_free = entry->next_free;

    entry->free = false;
    entry->next_free = $S_NULL_IDX;

    seq->len++;

    *ee = entry;
    if(ridx) {
      *ridx = idx;
    }
    return true;
  }
}

void $s_clear($s *seq, uint32_t start, uint32_t end);
awasm_success $s_init($s *seq, uint$w_t capa);
$e *$s_delete($s *seq, $e *e);
void $s_destroy($s *seq);
$e * $s_data($s *seq);
