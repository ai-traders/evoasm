
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include "$-s.h"
#include "evoasm-error.h"
#include "evoasm-alloc.h"
#include "evoasm-val.h"

#define $S_NULL_IDX (uint$w_t) -1

void
$s_destroy($s *graph) {
  $nl_destroy(&graph->nodes);
  $el_destroy(&graph->edges);
}

evoasm_success
$s_init($s *graph, uint$w_t capa) {
  EVOASM_TRY(nodes_error, $nl_init, &graph->nodes, capa);
  EVOASM_TRY(edges_error, $el_init, &graph->edges, capa);

  return true;

nodes_error:
  return false;
edges_error:
  $nl_destroy(&graph->nodes);
  return false;
}

evoasm_success
$s_add($s *graph, $n **node) {
  EVOASM_TRY(error, $nl_push, &graph->nodes, node, NULL);
  (*node)->edge_idx = $S_NULL_IDX;
  return true;

error:
  return false;
}

evoasm_success
$s_link($s *graph, $n *node_from, $n *node_to, $e label) {

  uint$w_t from = $s_node_index(graph, node_from);
  uint$w_t to = $s_node_index(graph, node_to);

  $e *edge_in, *edge_out;
  uint$w_t edge_in_idx, edge_out_idx;

  EVOASM_TRY(push1_error, $el_push, &graph->edges, &edge_in, &edge_in_idx);
  EVOASM_TRY(push2_error, $el_push, &graph->edges, &edge_out, &edge_out_idx);

  *edge_out = {
      .dir = $E_DIR_OUT,
      .label = label,
      .node_idx = from,
      .edge_idx = node_from->edge_idx,
  };

  *edge_in = {
      .dir = $E_DIR_IN,
      .label = label,
      .node_idx = to,
      .edge_idx = node_to->edge_idx
  };

  node_from->edge_idx = edge_out_idx;
  node_to->edge_idx = edge_in_idx;

  return true;
}

static bool
$s_edge_eql($e *a, $e b) {
  $edge_eql
}

static $e *
$s_delete_edge($s *graph, $n *node, $e *edge) {
  uint$w_t i;

  for(i = node->edge_idx; i != $S_NULL_IDX;) {
    $e *edge = $el_get(&graph->edges, i);

    if($edge_eql(edge, &edge_out)) {
      return $el_delete(&graph->edges, edge)
    }
    i = edge->edge_idx;
  }

  return NULL;
}

evoasm_success
$s_unlink($s *graph, $n *node_from, $n *node_to, $l label) {

  uint$w_t from = $s_node_index(graph, node_from);
  uint$w_t to = $s_node_index(graph, node_to);

  $e edge_out = {
    .dir = $E_DIR_OUT,
    .label = label,
    .node_idx = to
  };

  $e edge_in = {
    .dir = $E_DIR_IN,
    .label = label,
    .node_idx = from
  };

  $s_delete_edge(graph, node_from, &edge_out);
  $s_delete_edge(graph, node_to, &edge_in);
  return true;
}

uint$w_t
$s_size($s *graph) {
  return graph->nodes.len;
}

static evoasm_success
$s_unlink_node($s *graph, $n *node) {
  $e *edges = $el_data(&node->edges);
  uint$w_t i;

  for(i = node->edge_idx; i != $S_NULL_IDX;) {
    $e *edge = $el_get(&graph->edges, i);
    if(edge->dir == $E_DIR_IN) {
      node1 = $nl_get(&graph->nodes, edge->node_idx);
      node2 = node;
    } else {
      node1 = node;
      node2 = $nl_get(&graph->nodes, edge->node_idx);
    }
    if(!$s_unlink(graph, node1, node2, edge->idx)) return false;
  }
  return true;
}

bool
$s_delete($s *graph, $n *node) {
  if(!$s_unlink_node(graph, node)) {
    return false;
  }
  if(!$nl_delete(&graph->nodes, node)) {
    /* must exist at this point, or something is wrong */
    evoasm_assert_not_reached();
  }
  return true;
}
