/* AUTOGENERATED FILE, DO NOT EDIT */

#include "evoasm-x64.h"
#include "evoasm-error.h"

static const char *_evoasm_log_tag = "x64";

uint8_t evoasm_x64_reg_type_sizes[EVOASM_X64_N_REG_TYPES] = {0};

static int64_t
evoasm_x64_disp_size(evoasm_x64 *x64, evoasm_arch_param_val *param_vals, evoasm_bitmap *set_params) {
  evoasm_arch_param_val val = param_vals[EVOASM_X64_PARAM_DISP];
  if(!evoasm_bitmap_get(set_params, EVOASM_X64_PARAM_DISP)) return 0;
  if(val >= INT8_MIN && val <= INT8_MAX) return 8;
  if(val >= INT32_MIN && val <= INT32_MAX) return 32;
  return 0;
}

static int8_t
evoasm_x64_reg_code(evoasm_x64 *x64, evoasm_x64_reg_id reg) {
  switch(reg) {
<% Evoasm::Gen::X64::REGISTERS.fetch_values(:gp, :mm, :xmm, :zmm).each do |regs| %>
<% regs.each_with_index do |reg, index| %>
    case <%= reg_name_to_c reg %>: return <%= index %>;
<%end %>
<%end %>
  default:
    evoasm_fatal("invalid register id %d", reg);
    evoasm_assert_not_reached();
  }
}

/* PERMUTATION TABLES */
<%= permutation_tables %>
/* ------------------- */

/* FUNCS */
<%= called_funcs %>
/* ------------------- */

<%= pref_funcs %>
<%= inst_funcs %>
<%= param_domains %>
<%= inst_params %>
<%= inst_operands %>

<%= insts_c %>

static evoasm_x64_reg_id evoasm_x64_sysv_callee_save_regs[] = {
  EVOASM_X64_REG_BP,
  EVOASM_X64_REG_B,
  EVOASM_X64_REG_12,
  EVOASM_X64_REG_13,
  EVOASM_X64_REG_14,
  EVOASM_X64_REG_15,
};

static evoasm_success
evoasm_x64_func_prolog_or_epilog(evoasm_x64 *x64, evoasm_buf *buf, evoasm_x64_abi abi, bool prolog) {
  evoasm_arch *arch = (evoasm_arch *) x64;
  unsigned i;
  size_t regs_len = EVOASM_ARY_LEN(evoasm_x64_sysv_callee_save_regs);
  evoasm_x64_params params = {0};

  /* touch RSP and RBX so we don't get a read access violation for PUSH */
  //evoasm_arch_write_access(arch, (evoasm_bitmap *) &arch->acc, EVOASM_X64_REG_SP);

  for(i = 0; i < regs_len; i++) {
    evoasm_x64_reg_id reg = evoasm_x64_sysv_callee_save_regs[prolog ? i : (regs_len - 1 - i)];
    evoasm_arch_write_access(arch, (evoasm_bitmap *) &arch->acc, reg);
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, reg);

    if(prolog) {
      EVOASM_X64_ENC(push_r64);
    }
    else {
      EVOASM_X64_ENC(pop_r64);
    }
    evoasm_arch_save(arch, buf);
  }

  if(!prolog) {
    EVOASM_X64_ENC(ret);
    evoasm_arch_save(arch, buf);
  }

  return true;

enc_failed:
  return false;
}

evoasm_success
evoasm_x64_func_prolog(evoasm_x64 *x64, evoasm_buf *buf, evoasm_x64_abi abi) {
  return evoasm_x64_func_prolog_or_epilog(x64, buf, abi, true);
}

evoasm_success
evoasm_x64_func_epilog(evoasm_x64 *x64, evoasm_buf *buf, evoasm_x64_abi abi) {
  return evoasm_x64_func_prolog_or_epilog(x64, buf, abi, false);
}

static evoasm_success
evoasm_x64_load_cpuid(evoasm_x64 *x64) {
  evoasm_buf buf;
  evoasm_x64_params params = {0};
  bool retval = true;

  uint32_t vals[<%= Evoasm::Gen::X64::CPUID.size %>][<%= Evoasm::Gen::X64::CPUID.max_by{|k, v| v.size}.size %>] = {0};
  evoasm_arch *arch = (evoasm_arch *) x64;

  evoasm_debug("Running CPUID...");

  EVOASM_TRY(alloc_failed, evoasm_buf_init, &buf, EVOASM_BUF_TYPE_MMAP, 512);

  EVOASM_TRY(enc_failed, evoasm_x64_func_prolog, x64, &buf, EVOASM_X64_ABI_SYSV);

<% remaining_flags = features.keys %>
<% io = StrIO.new %>
<% Evoasm::Gen::X64::CPUID.each_with_index do |((eax_val, ecx_val), out_regs), index0| %>

  EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_A);
  EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, <%= eax_val %>);
  EVOASM_X64_ENC(mov_r32_imm32);
  evoasm_arch_save(arch, &buf);

  <% if ecx_val %>
  EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_C);
  EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, <%= ecx_val %>);
  EVOASM_X64_ENC(mov_r32_imm32);
  evoasm_arch_save(arch, &buf);
  <% end %>

  EVOASM_X64_ENC(cpuid);
  evoasm_arch_save(arch, &buf);

  <% out_regs.each.with_index do |(reg, flags), index1| %>

  {
    evoasm_arch_param_val addr_imm;
    addr_imm = (evoasm_arch_param_val)(uintptr_t) &vals[<%= index0 %>][<%= index1 %>];
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_DI);
    EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, addr_imm);
    EVOASM_X64_ENC(mov_r64_imm64);
    evoasm_arch_save(arch, &buf);

    EVOASM_X64_SET(EVOASM_X64_PARAM_REG1, <%= reg_name_to_c reg %>);
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG_BASE, EVOASM_X64_REG_DI);
    EVOASM_X64_ENC(mov_rm32_r32);
    evoasm_arch_save(arch, &buf);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_ADDRESS_SIZE);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_REG_BASE);

    <% flags.each_with_index do |flag, bit_index| %>
      <% if remaining_flags.delete(flag) %>
        <% io.indent 1 do %>
          <% io.puts "if(vals[#{index0}][#{index1}] & (1 << #{bit_index})) {" %>
          <% io.puts "  x64->features |= #{feature_name_to_c flag};" %>
          <% io.puts %{  evoasm_info("Found support for #{flag.upcase}");} %>
          <% io.puts "} else {" %>
          <% io.puts %{  evoasm_info("Missing support for #{flag.upcase}");} %>
          <% io.puts "}" %>
        <% end %>
      <% end %>
    <% end %>
  }
  <% end%>
<% end %>

  EVOASM_TRY(enc_failed, evoasm_x64_func_epilog, x64, &buf, EVOASM_X64_ABI_SYSV);

  /*evoasm_buf_dump(&buf, stderr);*/

  EVOASM_TRY(enc_failed, evoasm_buf_protect, &buf, EVOASM_BUF_PROT_X);
  evoasm_buf_exec(&buf);

<%= io.string %>

cleanup:
  EVOASM_TRY(destroy_failed, evoasm_buf_destroy, &buf);
  return retval;
enc_failed:
  retval = false;
  goto cleanup;
destroy_failed:
  return false;
alloc_failed:
  return false;

}

static uint16_t
evoasm_x64_insts(evoasm_x64 *x64, const evoasm_x64_inst **insts) {
  uint16_t len = 0;
  const evoasm_x64_inst *inst;
  /* Assuming that at least some feature is found */

  <% insts.each do |inst| %>
  inst = &<%= insts_var_name %>[<%= inst.index %>];
  if((inst->features & ~x64->features) == 0) insts[len++] = inst;
  <% end %>

  return len;
}

const evoasm_x64_inst *
evoasm_x64_get_inst(evoasm_x64 *x64, unsigned index, bool ignore_features) {
  const evoasm_x64_inst *inst = &<%= insts_var_name %>[index];
  if(ignore_features || (inst->features & ~x64->features) == 0) return inst;
  return NULL;
}

static evoasm_arch_cls evoasm_x64_cls = {
  EVOASM_ARCH_X64,
  EVOASM_X64_N_INSTS,
  EVOASM_X64_N_PARAMS,
  15,
  (evoasm_arch_insts_func) evoasm_x64_insts,
};


evoasm_success
evoasm_x64_init(evoasm_x64 *x64) {
  static evoasm_x64 zero_x64 = {0};
  evoasm_arch *arch = (evoasm_arch *) x64;
  *x64 = zero_x64;

  evoasm_arch_init(arch, &evoasm_x64_cls);
  EVOASM_TRY(cpuid_failed, evoasm_x64_load_cpuid, x64);

  evoasm_x64_reg_type_sizes[EVOASM_X64_REG_TYPE_GP] = 8;

#ifdef EVOASM_X64_ENABLE_AVX512
  uint64_t avx512 = EVOASM_X64_FEATURE_AVX512F |
                    EVOASM_X64_FEATURE_AVX512DQ |
                    EVOASM_X64_FEATURE_AVX512IFMA |
                    EVOASM_X64_FEATURE_AVX512PF |
                    EVOASM_X64_FEATURE_AVX512ER |
                    EVOASM_X64_FEATURE_AVX512CD |
                    EVOASM_X64_FEATURE_AVX512BW |
                    EVOASM_X64_FEATURE_AVX512VL;

  if(x64->features & avx512) {
    evoasm_x64_reg_type_sizes[EVOASM_X64_REG_TYPE_XMM] = 64;
    evoasm_x64_reg_type_sizes[EVOASM_X64_REG_TYPE_ZMM] = 64;
  }
  else
#endif
  if(x64->features & EVOASM_X64_FEATURE_AVX2) {
    evoasm_x64_reg_type_sizes[EVOASM_X64_REG_TYPE_XMM] = 32;
  } else {
    evoasm_x64_reg_type_sizes[EVOASM_X64_REG_TYPE_XMM] = 16;
  }
  return true;

cpuid_failed:
  evoasm_arch_destroy(arch);
  return false;
}

void
evoasm_x64_destroy(evoasm_x64 *x64) {
  evoasm_arch *arch = (evoasm_arch *) x64;
  evoasm_arch_destroy(arch);
}

<% if options[:ruby] %>

extern VALUE evoasm_cX64Instruction;

static ID _rb_x64_inst_ids[<%= insts.size %>];
static ID _rb_x64_reg_ids[<%= reg_names.n %>];
static ID _rb_x64_param_ids[<%= param_names.n %>];
static ID _rb_x64_reg_type_ids[<%= Evoasm::Gen::X64::REGISTERS.size %>];
static ID _rb_x64_operand_type_ids[<%= Evoasm::Gen::X64::REGISTERS.size %>];

ID *rb_x64_inst_ids =_rb_x64_inst_ids ;
ID *rb_x64_reg_ids = _rb_x64_reg_ids;
ID *rb_x64_param_ids = _rb_x64_param_ids;
ID *rb_x64_operand_type_ids= _rb_x64_operand_type_ids;
ID *rb_x64_reg_type_ids = _rb_x64_reg_type_ids;

void evoasm_x64_ruby_define_consts() {

<% Evoasm::Gen::X64::Inst::OPERAND_TYPES.each_with_index do |operand_type, index| %>
  rb_x64_operand_type_ids[<%= index %>] = rb_intern("<%= operand_type %>");
<% end %>


<% Evoasm::Gen::X64::REGISTERS.keys.each_with_index do |reg_type, index| %>
  rb_x64_reg_type_ids[<%= index %>] = rb_intern("<%= reg_type.to_s %>");
<% end %>

<% param_names.each do |name, index| %>
  rb_x64_param_ids[<%= index %>] = rb_intern("<%= name.to_s %>");
<% end %>

<% features.each do |name, index| %>
  rb_define_const(evoasm_cX64Instruction,
      "FEATURE_<%= name.upcase %>",
      INT2FIX(<%= feature_name_to_c name %>));
<% end %>

<% inst_flags.each do |name, index| %>
  rb_define_const(evoasm_cX64Instruction,
      "FLAG_<%= name.upcase %>",
      INT2FIX(<%= inst_flag_to_c name %>));
<% end %>

<% insts.each_with_index do |inst, index| %>
  rb_x64_inst_ids[<%= index %>] = rb_intern("<%= inst.name.to_s %>");
<% end %>

<% reg_names.each do |name, index| %>
  rb_x64_reg_ids[<%= index %>] = rb_intern("<%= name =~ /^\d/ ? 'R' : '' %><%= name.to_s %>");
<% end %>
}
<% end %>
