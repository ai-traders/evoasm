/* AUTOGENERATED FILE, DO NOT EDIT */

#include "awasm-x64.h"
#include "awasm-error.h"

static const char *_awasm_log_tag = "x64";

uint8_t awasm_x64_reg_type_sizes[AWASM_X64_N_REG_TYPES] = {0};

static int64_t
awasm_x64_disp_size(awasm_x64 *x64, awasm_arch_param_val *param_vals, awasm_bitmap *set_params) {
  awasm_arch_param_val val = param_vals[AWASM_X64_PARAM_DISP];
  if(!awasm_bitmap_get(set_params, AWASM_X64_PARAM_DISP)) return 0;
  if(val >= INT8_MIN && val <= INT8_MAX) return 8;
  if(val >= INT32_MIN && val <= INT32_MAX) return 32;
  return 0;
}

static int8_t
awasm_x64_reg_code(awasm_x64 *x64, awasm_x64_reg_id reg) {
  switch(reg) {
<% Awasm::Gen::X64::REGISTERS.fetch_values(:gp, :mm, :xmm, :zmm).each do |regs| %>
<% regs.each_with_index do |reg, index| %>
    case <%= reg_name_to_c reg %>: return <%= index %>;
<%end %>
<%end %>
  default:
    awasm_fatal("invalid register id %d", reg);
    awasm_assert_not_reached();
  }
}

/* PERMUTATION TABLES */
<%= permutation_tables %>
/* ------------------- */

/* FUNCS */
<%= called_funcs %>
/* ------------------- */

<%= pref_funcs %>
<%= inst_funcs %>
<%= param_domains %>
<%= inst_params %>
<%= inst_operands %>

<%= insts_c %>

static awasm_x64_reg_id awasm_x64_sysv_callee_save_regs[] = {
  AWASM_X64_REG_BP,
  AWASM_X64_REG_B,
  AWASM_X64_REG_12,
  AWASM_X64_REG_13,
  AWASM_X64_REG_14,
  AWASM_X64_REG_15,
};

static awasm_success
awasm_x64_func_prolog_or_epilog(awasm_x64 *x64, awasm_buf *buf, awasm_x64_abi abi, bool prolog) {
  awasm_arch *arch = (awasm_arch *) x64;
  unsigned i;
  size_t regs_len = AWASM_ARY_LEN(awasm_x64_sysv_callee_save_regs);
  awasm_x64_params params = {0};

  /* touch RSP and RBX so we don't get a read access violation for PUSH */
  //awasm_arch_write_access(arch, (awasm_bitmap *) &arch->acc, AWASM_X64_REG_SP);

  for(i = 0; i < regs_len; i++) {
    awasm_x64_reg_id reg = awasm_x64_sysv_callee_save_regs[prolog ? i : (regs_len - 1 - i)];
    awasm_arch_write_access(arch, (awasm_bitmap *) &arch->acc, reg);
    AWASM_X64_SET(AWASM_X64_PARAM_REG0, reg);

    if(prolog) {
      AWASM_X64_ENC(push_r64);
    }
    else {
      AWASM_X64_ENC(pop_r64);
    }
    awasm_arch_save(arch, buf);
  }

  if(!prolog) {
    AWASM_X64_ENC(ret);
    awasm_arch_save(arch, buf);
  }

  return true;

enc_failed:
  return false;
}

awasm_success
awasm_x64_func_prolog(awasm_x64 *x64, awasm_buf *buf, awasm_x64_abi abi) {
  return awasm_x64_func_prolog_or_epilog(x64, buf, abi, true);
}

awasm_success
awasm_x64_func_epilog(awasm_x64 *x64, awasm_buf *buf, awasm_x64_abi abi) {
  return awasm_x64_func_prolog_or_epilog(x64, buf, abi, false);
}

static awasm_success
awasm_x64_load_cpuid(awasm_x64 *x64) {
  awasm_buf buf;
  awasm_x64_params params = {0};
  bool retval = true;

  uint32_t vals[<%= Awasm::Gen::X64::CPUID.size %>][<%= Awasm::Gen::X64::CPUID.max_by{|k, v| v.size}.size %>] = {0};
  awasm_arch *arch = (awasm_arch *) x64;

  awasm_debug("Running CPUID...");

  AWASM_TRY(alloc_failed, awasm_buf_init, &buf, AWASM_BUF_TYPE_MMAP, 512);

  AWASM_TRY(enc_failed, awasm_x64_func_prolog, x64, &buf, AWASM_X64_ABI_SYSV);

<% remaining_flags = features.keys %>
<% io = StrIO.new %>
<% Awasm::Gen::X64::CPUID.each_with_index do |((eax_val, ecx_val), out_regs), index0| %>

  AWASM_X64_SET(AWASM_X64_PARAM_REG0, AWASM_X64_REG_A);
  AWASM_X64_SET(AWASM_X64_PARAM_IMM0, <%= eax_val %>);
  AWASM_X64_ENC(mov_r32_imm32);
  awasm_arch_save(arch, &buf);

  <% if ecx_val %>
  AWASM_X64_SET(AWASM_X64_PARAM_REG0, AWASM_X64_REG_C);
  AWASM_X64_SET(AWASM_X64_PARAM_IMM0, <%= ecx_val %>);
  AWASM_X64_ENC(mov_r32_imm32);
  awasm_arch_save(arch, &buf);
  <% end %>

  AWASM_X64_ENC(cpuid);
  awasm_arch_save(arch, &buf);

  <% out_regs.each.with_index do |(reg, flags), index1| %>

  {
    awasm_arch_param_val addr_imm;
    addr_imm = (awasm_arch_param_val)(uintptr_t) &vals[<%= index0 %>][<%= index1 %>];
    AWASM_X64_SET(AWASM_X64_PARAM_REG0, AWASM_X64_REG_DI);
    AWASM_X64_SET(AWASM_X64_PARAM_IMM0, addr_imm);
    AWASM_X64_ENC(mov_r64_imm64);
    awasm_arch_save(arch, &buf);

    AWASM_X64_SET(AWASM_X64_PARAM_REG1, <%= reg_name_to_c reg %>);
    AWASM_X64_SET(AWASM_X64_PARAM_REG_BASE, AWASM_X64_REG_DI);
    AWASM_X64_ENC(mov_rm32_r32);
    awasm_arch_save(arch, &buf);
    AWASM_X64_UNSET(AWASM_X64_PARAM_ADDRESS_SIZE);
    AWASM_X64_UNSET(AWASM_X64_PARAM_REG_BASE);

    <% flags.each_with_index do |flag, bit_index| %>
      <% if remaining_flags.delete(flag) %>
        <% io.indent 1 do %>
          <% io.puts "if(vals[#{index0}][#{index1}] & (1 << #{bit_index})) {" %>
          <% io.puts "  x64->features |= #{feature_name_to_c flag};" %>
          <% io.puts %{  awasm_info("Found support for #{flag.upcase}");} %>
          <% io.puts "} else {" %>
          <% io.puts %{  awasm_info("Missing support for #{flag.upcase}");} %>
          <% io.puts "}" %>
        <% end %>
      <% end %>
    <% end %>
  }
  <% end%>
<% end %>

  AWASM_TRY(enc_failed, awasm_x64_func_epilog, x64, &buf, AWASM_X64_ABI_SYSV);

  /*awasm_buf_dump(&buf, stderr);*/

  AWASM_TRY(enc_failed, awasm_buf_protect, &buf, AWASM_BUF_PROT_X);
  awasm_buf_exec(&buf);

<%= io.string %>

cleanup:
  AWASM_TRY(destroy_failed, awasm_buf_destroy, &buf);
  return retval;
enc_failed:
  retval = false;
  goto cleanup;
destroy_failed:
  return false;
alloc_failed:
  return false;

}

static uint16_t
awasm_x64_insts(awasm_x64 *x64, const awasm_x64_inst **insts) {
  uint16_t len = 0;
  const awasm_x64_inst *inst;
  /* Assuming that at least some feature is found */

  <% insts.each do |inst| %>
  inst = &<%= insts_var_name %>[<%= inst.index %>];
  if((inst->features & ~x64->features) == 0) insts[len++] = inst;
  <% end %>

  return len;
}

const awasm_x64_inst *
awasm_x64_get_inst(awasm_x64 *x64, unsigned index, bool ignore_features) {
  const awasm_x64_inst *inst = &<%= insts_var_name %>[index];
  if(ignore_features || (inst->features & ~x64->features) == 0) return inst;
  return NULL;
}

static awasm_arch_cls awasm_x64_cls = {
  AWASM_ARCH_X64,
  AWASM_X64_N_INSTS,
  AWASM_X64_N_PARAMS,
  15,
  (awasm_arch_insts_func) awasm_x64_insts,
};


awasm_success
awasm_x64_init(awasm_x64 *x64) {
  static awasm_x64 zero_x64 = {0};
  awasm_arch *arch = (awasm_arch *) x64;
  *x64 = zero_x64;

  awasm_arch_init(arch, &awasm_x64_cls);
  AWASM_TRY(cpuid_failed, awasm_x64_load_cpuid, x64);

  awasm_x64_reg_type_sizes[AWASM_X64_REG_TYPE_GP] = 8;

#ifdef AWASM_X64_ENABLE_AVX512
  uint64_t avx512 = AWASM_X64_FEATURE_AVX512F |
                    AWASM_X64_FEATURE_AVX512DQ |
                    AWASM_X64_FEATURE_AVX512IFMA |
                    AWASM_X64_FEATURE_AVX512PF |
                    AWASM_X64_FEATURE_AVX512ER |
                    AWASM_X64_FEATURE_AVX512CD |
                    AWASM_X64_FEATURE_AVX512BW |
                    AWASM_X64_FEATURE_AVX512VL;

  if(x64->features & avx512) {
    awasm_x64_reg_type_sizes[AWASM_X64_REG_TYPE_XMM] = 64;
    awasm_x64_reg_type_sizes[AWASM_X64_REG_TYPE_ZMM] = 64;
  }
  else
#endif
  if(x64->features & AWASM_X64_FEATURE_AVX2) {
    awasm_x64_reg_type_sizes[AWASM_X64_REG_TYPE_XMM] = 32;
  } else {
    awasm_x64_reg_type_sizes[AWASM_X64_REG_TYPE_XMM] = 16;
  }
  return true;

cpuid_failed:
  awasm_arch_destroy(arch);
  return false;
}

void
awasm_x64_destroy(awasm_x64 *x64) {
  awasm_arch *arch = (awasm_arch *) x64;
  awasm_arch_destroy(arch);
}

<% if options[:ruby] %>

extern VALUE awasm_cX64Instruction;

static ID _rb_x64_inst_ids[<%= insts.size %>];
static ID _rb_x64_reg_ids[<%= reg_names.n %>];
static ID _rb_x64_param_ids[<%= param_names.n %>];
static ID _rb_x64_reg_type_ids[<%= Awasm::Gen::X64::REGISTERS.size %>];
static ID _rb_x64_operand_type_ids[<%= Awasm::Gen::X64::REGISTERS.size %>];

ID *rb_x64_inst_ids =_rb_x64_inst_ids ;
ID *rb_x64_reg_ids = _rb_x64_reg_ids;
ID *rb_x64_param_ids = _rb_x64_param_ids;
ID *rb_x64_operand_type_ids= _rb_x64_operand_type_ids;
ID *rb_x64_reg_type_ids = _rb_x64_reg_type_ids;

void awasm_x64_ruby_define_consts() {

<% Awasm::Gen::X64::Inst::OPERAND_TYPES.each_with_index do |operand_type, index| %>
  rb_x64_operand_type_ids[<%= index %>] = rb_intern("<%= operand_type %>");
<% end %>


<% Awasm::Gen::X64::REGISTERS.keys.each_with_index do |reg_type, index| %>
  rb_x64_reg_type_ids[<%= index %>] = rb_intern("<%= reg_type.to_s %>");
<% end %>

<% param_names.each do |name, index| %>
  rb_x64_param_ids[<%= index %>] = rb_intern("<%= name.to_s %>");
<% end %>

<% features.each do |name, index| %>
  rb_define_const(awasm_cX64Instruction,
      "FEATURE_<%= name.upcase %>",
      INT2FIX(<%= feature_name_to_c name %>));
<% end %>

<% inst_flags.each do |name, index| %>
  rb_define_const(awasm_cX64Instruction,
      "FLAG_<%= name.upcase %>",
      INT2FIX(<%= inst_flag_to_c name %>));
<% end %>

<% insts.each_with_index do |inst, index| %>
  rb_x64_inst_ids[<%= index %>] = rb_intern("<%= inst.name.to_s %>");
<% end %>

<% reg_names.each do |name, index| %>
  rb_x64_reg_ids[<%= index %>] = rb_intern("<%= name =~ /^\d/ ? 'R' : '' %><%= name.to_s %>");
<% end %>
}
<% end %>
