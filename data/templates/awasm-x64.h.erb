/* vim: set filetype=c: */
/* AUTOGENERATED FILE, DO NOT EDIT */

#pragma once

#include "awasm.h"
#include "awasm-util.h"

#include <stdint.h>

<%= features.to_c %>

<%= inst_flags.to_c %>

<%= exceptions.to_c %>

<%= reg_types.to_c typedef: false %>

extern uint8_t awasm_x64_reg_type_sizes[AWASM_X64_N_REG_TYPES];

<%= reg_names.to_c %>

static inline enum awasm_x64_reg_type
awasm_x64_reg_type(awasm_x64_reg_id reg) {
  switch(reg) {
<% Awasm::Gen::X64::REGISTERS.each do |reg_type, regs| %>
  <% regs.each do |reg| %>
    case <%= reg_name_to_c reg %>: return <%= reg_type_to_c reg_type %>;
  <% end %>
<% end %>
    default: awasm_assert_not_reached();
  }
}

<%= param_names.to_c %>

typedef enum {
<% insts.each do |inst| %>
  <%= inst_name_to_c inst %> = <%= inst.index %>,
<% end %>
  AWASM_X64_N_INSTS = <%= insts.size %>,
} awasm_x64_inst_id;

typedef struct {
  _AWASM_ARCH_PARAMS_HEADER
  awasm_arch_param_val vals[AWASM_X64_N_PARAMS];
} awasm_x64_params;

_Static_assert(AWASM_X64_N_PARAMS <= AWASM_ARCH_MAX_PARAMS, "Too much parameters. Redeclar AWASM_ARCH_MAX_PARAMS and awasm_arch_params_bitmap.");

typedef struct {
  awasm_arch base;
  uint64_t features;
} awasm_x64;

<%= operand_types.to_c %>

typedef enum {
  AWASM_X64_OPERAND_SIZE_UNKNOWN,
  AWASM_X64_OPERAND_SIZE_1,
  AWASM_X64_OPERAND_SIZE_8,
  AWASM_X64_OPERAND_SIZE_16,
  AWASM_X64_OPERAND_SIZE_32,
  AWASM_X64_OPERAND_SIZE_64,
  AWASM_X64_OPERAND_SIZE_128,
  AWASM_X64_OPERAND_SIZE_256,
  AWASM_X64_OPERAND_SIZE_512,
} awasm_x64_operand_size;

typedef struct {
  unsigned type: 3;
  unsigned acc_r: 1;
  unsigned acc_w: 1;
  unsigned acc_u: 1;
  unsigned acc_c: 1;
  unsigned implicit: 1;
  unsigned reg_type: 3;
  unsigned reg_id: 7;
  unsigned param_idx: 5;
  unsigned size: 4;
} awasm_x64_operand;

typedef struct {
  awasm_inst base;
  uint64_t features;
  awasm_x64_operand *operands;
  uint8_t n_operands;
  uint32_t exceptions;
  uint32_t flags;
} awasm_x64_inst;

#define AWASM_X64_ENC(inst) \
  AWASM_TRY(enc_failed, awasm_x64_##inst, x64, params.vals, (awasm_bitmap *) &params.set)

#define AWASM_X64_SET(param, val) \
  awasm_arch_params_set(params.vals, (awasm_bitmap *) &params.set, param, val)

#define AWASM_X64_UNSET(param) \
  awasm_arch_params_unset(params.vals, (awasm_bitmap *) &params.set, param)

typedef enum {
  AWASM_X64_ABI_SYSV
} awasm_x64_abi;

void
awasm_x64_destroy(awasm_x64 *x64);

awasm_success
awasm_x64_init(awasm_x64 *x64);

awasm_success
awasm_x64_func_prolog(awasm_x64 *x64, awasm_buf *buf, awasm_x64_abi abi);

awasm_success
awasm_x64_func_epilog(awasm_x64 *x64, awasm_buf *buf, awasm_x64_abi abi);

const awasm_x64_inst *
awasm_x64_get_inst(awasm_x64 *x64, unsigned index, bool ignore_features);

<% insts.each do |inst| %>
<%= func_prototype_to_c(inst.name, static: false) %>;
<% end %>
<% if options[:ruby] %>

#include <ruby.h>

extern ID *rb_x64_inst_ids;
extern ID *rb_x64_reg_ids;
extern ID *rb_x64_param_ids;
extern ID *rb_x64_operand_type_ids;
extern ID *rb_x64_reg_type_ids;
void awasm_x64_ruby_define_consts();
<% end %>
