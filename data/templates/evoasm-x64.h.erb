/* vim: set filetype=c: */
/* AUTOGENERATED FILE, DO NOT EDIT */

#pragma once

#include "evoasm.h"
#include "evoasm-util.h"

#include <stdint.h>

<%= features.to_c %>

<%= inst_flags.to_c %>

<%= exceptions.to_c %>

<%= reg_types.to_c typedef: false %>

typedef enum {
  EVOASM_X64_REG_SEG_64 = 1,
  EVOASM_X64_REG_SEG_32,
  EVOASM_X64_REG_SEG_16,
  EVOASM_X64_REG_SEG_8U,
  EVOASM_X64_REG_SEG_8L,
} evoasm_x64_reg_seg_id;

extern uint8_t evoasm_x64_reg_type_sizes[EVOASM_X64_N_REG_TYPES];

<%= reg_names.to_c %>

static inline enum evoasm_x64_reg_type
evoasm_x64_reg_type(evoasm_x64_reg_id reg) {
  switch(reg) {
<% Evoasm::Gen::X64::REGISTERS.each do |reg_type, regs| %>
  <% regs.each do |reg| %>
    case <%= reg_name_to_c reg %>: return <%= reg_type_to_c reg_type %>;
  <% end %>
<% end %>
    default: evoasm_assert_not_reached();
  }
}

<%= param_names.to_c %>

typedef enum {
<% insts.each do |inst| %>
  <%= inst_name_to_c inst %> = <%= inst.index %>,
<% end %>
  EVOASM_X64_N_INSTS = <%= insts.size %>,
} evoasm_x64_inst_id;

typedef struct {
  _EVOASM_ARCH_PARAMS_HEADER
  evoasm_arch_param_val vals[EVOASM_X64_N_PARAMS];
} evoasm_x64_params;

_Static_assert(EVOASM_X64_N_PARAMS <= EVOASM_ARCH_MAX_PARAMS, "Too much parameters. Redeclar EVOASM_ARCH_MAX_PARAMS and evoasm_arch_params_bitmap.");

typedef struct {
  evoasm_arch base;
  uint64_t features;
} evoasm_x64;

<%= operand_types.to_c %>

typedef struct {
  unsigned type: 3;
  unsigned acc_r: 1;
  unsigned acc_w: 1;
  unsigned acc_u: 1;
  unsigned acc_c: 1;
  unsigned implicit: 1;
  unsigned reg_type: 3;
  unsigned reg_id: 7;
  unsigned param_idx: 5;
  unsigned size: 4;
} evoasm_x64_operand;

typedef struct {
  evoasm_inst base;
  uint64_t features;
  evoasm_x64_operand *operands;
  uint8_t n_operands;
  uint32_t exceptions;
  uint32_t flags;
} evoasm_x64_inst;

#define EVOASM_X64_ENC(inst) \
  EVOASM_TRY(enc_failed, evoasm_x64_##inst, x64, params.vals, (evoasm_bitmap *) &params.set)

#define EVOASM_X64_SET(param, val) \
  evoasm_arch_params_set(params.vals, (evoasm_bitmap *) &params.set, param, val)

#define EVOASM_X64_UNSET(param) \
  evoasm_arch_params_unset(params.vals, (evoasm_bitmap *) &params.set, param)

typedef enum {
  EVOASM_X64_ABI_SYSV
} evoasm_x64_abi;

void
evoasm_x64_destroy(evoasm_x64 *x64);

evoasm_success
evoasm_x64_init(evoasm_x64 *x64);

evoasm_success
evoasm_x64_func_prolog(evoasm_x64 *x64, evoasm_buf *buf, evoasm_x64_abi abi);

evoasm_success
evoasm_x64_func_epilog(evoasm_x64 *x64, evoasm_buf *buf, evoasm_x64_abi abi);

const evoasm_x64_inst *
evoasm_x64_get_inst(evoasm_x64 *x64, unsigned index, bool ignore_features);

<% insts.each do |inst| %>
<%= func_prototype_to_c(inst.name, static: false) %>;
<% end %>
<% if options[:ruby] %>

#include <ruby.h>

extern ID *rb_x64_inst_ids;
extern ID *rb_x64_reg_ids;
extern ID *rb_x64_param_ids;
extern ID *rb_x64_operand_type_ids;
extern ID *rb_x64_reg_type_ids;
void evoasm_x64_ruby_define_consts();
<% end %>
